#!/usr/bin/env ruby

require "gtk3"
require "gstreamer"
require "fileutils"

class GsbdWindow < Gtk::ApplicationWindow
  def initialize
    super(application)

    header = Gtk::HeaderBar.new
    header.set_title("GifShouldBeDead")
    header.show_close_button = true
    set_titlebar(header)
    record_button = Gtk::Button.new(:label => "Record")
    stop_button = Gtk::Button.new(:label => "Stop")
    stop_button.sensitive = false

    record_button.signal_connect "clicked" do |widget|
      stop_button.sensitive = true
      @recorder = Recorder.new("rec.webm", 0, 0)
      @recorder.record
       widget.sensitive = false
    end

    stop_button.signal_connect "clicked" do |widget|
      @recorder.stop_record if @recorder
      record_button.sensitive = true
      widget.sensitive = false
    end

    set_default_size(-1, 0)
    header.pack_start(record_button)
    header.pack_end(stop_button)

    signal_connect("delete_event") { Gtk.main_quit }
  end
end

class Recorder
  def initialize(output_file, startx = 0, starty = 0, endx = nil, endy=nil)
    @pipeline = Gst::Pipeline.new("my-pipeline")
    desc = "ximagesrc " + "startx=#{startx} starty=#{starty} "
    desc += "endx=#{endx} " if endx
    desc += "endy=#{endy} " if endy
    desc += "name=\"videosrc\" !video/x-raw,framerate=25/1 ! queue ! videoconvert ! queue ! vp8enc ! queue"

    videobin = Gst.parse_bin_from_description(desc, true)
    mux = Gst::ElementFactory.make("webmmux")
    sink = Gst::ElementFactory.make("filesink")
    sink.location = output_file
    @pipeline << videobin << mux << sink
    videopad = mux.get_request_pad("video_%u")
    videobin.get_static_pad("src").link(videopad)
    mux.link(sink)
  end

  def record
    @pipeline.state = :playing
  end

  def stop_record
    eos_event = Gst::Event.new
    eos_event.type = Gst::EventType::EOS
    @pipeline.send_event(eos_event)
    @pipeline.state = :null
  end
end

require "optparse"

class GsbdApplication < Gtk::Application
  attr_accessor :settings
  def initialize
    @options = {}
    @exit_status = 0

    super("com.github.cedlemo.gifshouldbedead", [:non_unique,:handles_command_line])

    signal_connect "startup" do |application|
      initialize_css_provider
      load_css_config
    end

    signal_connect "activate" do |application|

      window = GsbdWindow.new(application)
      window.present

      if @options[:execute]
        window.add_terminal(@options[:execute])
      else
        window.add_terminal
      end
      window.terminal.grab_focus
    end


    signal_connect "command-line" do |_application, command_line|
      begin
        parse_command_line(command_line.arguments)
      rescue SystemExit => error
        error.status
      rescue OptionParser::InvalidOption => error
        STDERR.puts error.message
        1
      rescue => error
        STDERR.puts "#{error.class}: #{error.message}"
        STDERR.puts error.backtrace
        1
      else
        activate
        @exit_status
      end
    end
  end

  def check_css_file_path
    css_file = if File.exist?(@settings["css-file"])
                 @settings["css-file"]
               else
                 "#{CONFIG_DIR}/#{@settings["css-file"]}"
               end
    File.exist?(css_file) ? css_file : nil
  end

  private

  def parse_command_line(arguments)
    parser = OptionParser.new
    parser.on("-x", "--xposition X_COORDINATE", Integer, "X position to start recording") do |x|
      @options[:x] = x
    end
    parser.on("-y", "--yposition Y_COORDINATE", Integer, "Y position to start recording") do |y|
      @options[:y] = y
    end
    parser.on("-w", "--width WIDTH", Integer, "Width of the recording") do |w|
      @options[:w] = w
    end
    parser.on("-h", "--height HEIGHT", Integer, "Height of the recording") do |h|
      @options[:h] = h
    end
    parser.on("-o", "--output FILENAME", String, "Name for the ouput file") do |o|
      @options[:o] = o
    end

    parser.parse(arguments)
  end

  def initialize_css_provider
    screen = Gdk::Display.default.default_screen
    @provider = Gtk::CssProvider.new
    Gtk::StyleContext.add_provider_for_screen(screen,
                                              @provider,
                                              Gtk::StyleProvider::PRIORITY_USER)
  end

  def load_custom_css(file)
    if @settings["custom-css"]
      @css_content = File.open(file, "r").read
      @provider.load(:data => @css_content)
    else
      @provider.load(:data => "")
    end
  end

  def load_css_config
    return unless @settings["custom-css"]
    css_file = check_css_file_path
    if css_file
      begin
        load_custom_css(css_file)
      rescue => e
        puts "Bad css file using default css #{e.message}"
        error_popup = TopinambourCssErrorPopup.new(self.windows.first)
        error_popup.message = e.message + "\n\nBad css file using default css"
        error_popup.show_all
      end
    else
      puts "No custom CSS, using default theme"
    end
  end

  def check_and_create_if_no_config_dir
    Dir.mkdir(CONFIG_DIR) unless Dir.exist?(CONFIG_DIR)
  end

end

Signal.trap("INT") {
  STDERR.puts "\tgifshouldbedead processus pid = #{Process.pid} has been interrupted with Ctrl-C"
  exit
}

Signal.trap("TERM") {
  STDERR.puts "\tgifshouldbedead processus pid = #{Process.pid} has been killed"
  exit
}

CURRENT_PATH = File.expand_path(File.dirname(__FILE__))
LIB_PATH = "#{CURRENT_PATH}/../lib"
DATA_PATH = "#{CURRENT_PATH}/../data"
CONFIG_DIR = File.expand_path("#{ENV['HOME']}/.config/gifshouldbedead")
USR_CSS = "#{CONFIG_DIR}/gifshouldbedead.css"
gresource_bin = "#{DATA_PATH}/gifshouldbedead.gresource"

resource = Gio::Resource.load(gresource_bin)
Gio::Resources.register(resource)
# Load default libraries !!WARNING!! loading order matters

gifshouldbedead = GsbdApplication.new

exit(gifshouldbedead.run([$PROGRAM_NAME] + ARGV))
